╔═══════════════════════════════════════════════════════════════════════════════╗
║       REMOTE PUMP MONITORING & CONTROL SYSTEM VIA IoT                         ║
║                    Arduino Nano 33 IoT + SIM7070G LTE-M                       ║
╚═══════════════════════════════════════════════════════════════════════════════╝

═══════════════════════════════════════════════════════════════════════════════
1. SYSTEM OVERVIEW
═══════════════════════════════════════════════════════════════════════════════

HARDWARE:
  • MCU: Arduino Nano 33 IoT (SAMD21, ARM Cortex-M0+)
  • Modem: SIM7070G (LTE-M/NB-IoT, UART 115200 bps)
  • RS485: SERCOM0 (9600 bps) - Modbus RTU for water meter
  • Sensors:
    - 3x AC Current Transducer (ADC_PIN_1/2/3)
    - Battery Voltage Monitor (voltage divider 100kΩ/220kΩ)
    - Contact Sensor (pump on/off detection)
    - Main Power Detection (Input_Supply_V)
  • Relay: Latching relay (PWR_ON_PIN, PWR_OFF_PIN)

SOFTWARE:
  • Framework: Arduino + PlatformIO
  • Protocol: MQTT over TCP (LTE-M)
  • Encryption: ChaCha20-Poly1305 (AEAD)
  • Security: Time-window authentication (30s), unique nonce
  • Watchdog: 16 second timeout (Adafruit SleepyDog)

CONNECTION PARAMETERS:
  • APN: iot.1nce.net (1NCE IoT SIM)
  • MQTT Broker: broker.remotextr.com:1883
  • Topic Subscribe: xtr/server/{NODE_ID}
  • Topic Publish: xtr/nodes/{NODE_ID}
  • Credentials: Username/Password authentication


═══════════════════════════════════════════════════════════════════════════════
2. SOFTWARE ARCHITECTURE
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                               MAIN LOOP                                      │
│                                                                              │
│  [WDT Reset] → [Service Protection] → [Handle MQTT] → [Check Connections]  │
│       ↓              ↓                      ↓                  ↓             │
│  Every cycle    Every cycle          Real-time URC       Every 15s          │
│                 (120s timeout)       parsing                                 │
│                                                                              │
│  ← [Publish Message] ← [Service Pump Edge] ← [RS485 Read] ←                │
│      Every 15s/30s         Real-time            Before publish              │
└─────────────────────────────────────────────────────────────────────────────┘


MAIN MODULES:

A. SETUP (One-time initialization)
   ├─ Watchdog timer init (16s)
   ├─ GPIO configuration (relays, sensors, ADC)
   ├─ Serial interfaces (SIM7070G: 115200, RS485: 9600)
   ├─ Crypto key decode (64 hex chars → 32 bytes)
   ├─ Initial state detection (pump, main power)
   ├─ Modem verification & restart if needed
   ├─ GPRS connection (PDP context activation)
   ├─ MQTT connection & subscription
   └─ Ready to operate

B. LOOP (Main loop)
   ├─ WDT_RESET() - Reset watchdog each cycle
   ├─ serviceStartProtection() - Manage start protection
   ├─ handleMQTTMessages() - Process commands from server
   ├─ checkConnections() - Health check (every 15s)
   ├─ servicePumpEdgeAndStatus() - Detect state changes
   └─ publishMessage() - Send data (every 15s/30s)


═══════════════════════════════════════════════════════════════════════════════
3. DETAILED PROCESS FLOWS
═══════════════════════════════════════════════════════════════════════════════

┌──────────────────────────────────────────────────────────────────────────────┐
│ 3.1. RECEIVE AND PROCESS COMMANDS FROM SERVER (handleMQTTMessages)           │
└──────────────────────────────────────────────────────────────────────────────┘

STEP 1: Receive URC from modem
  → Wait for "+SMSUB" string from SIM7070
  → Extract HEX payload from between quotes

STEP 2: Decode HEX payload
  → hexDecode(payload) → binary buffer
  → Structure: [nonce(12 bytes) | ciphertext | tag(16 bytes)]
  → Minimum length: (12 + 16) * 2 = 56 hex chars

STEP 3: Get timestamp from nonce
  → nonce[4] = Hour (H)
  → nonce[5] = Minute (M)
  → nonce[6] = Second (S)
  → Convert to seconds: secMsg = H*3600 + M*60 + S

STEP 4: Get network time (try up to 5 times)
  → AT+CCLK? → "+CCLK: "YY/MM/DD,HH:MM:SS+TZ""
  → Parse to ISO-8601: "YYYY-MM-DDTHH:MM:SSZ"
  → Extract HH:MM:SS → secNow
  → If fail 5 times → discard message

STEP 5: Check time window
  → Δt = circular_diff(secMsg, secNow)
  → If Δt > 30s → discard (replay attack protection)

STEP 6: Decrypt payload
  → ChaCha20-Poly1305 decrypt(ciphertext, tag, nonce, key)
  → Verify tag integrity
  → Output: plain JSON

STEP 7: Parse JSON commands
  → jsonGetInt("X", value)
    ├─ X = 1 → turnOnPump() (if not in protection)
    └─ X = 0 → turnOffPump() + armStartProtection(120s)
  → jsonGetInt("onPulse", value)
    └─ Update onPulse (500-10000 ms)

STEP 8: Publish status update
  → Send new status immediately


┌──────────────────────────────────────────────────────────────────────────────┐
│ 3.2. PUBLISH DATA (publishMessage)                                           │
└──────────────────────────────────────────────────────────────────────────────┘

STEP 1: Collect sensor data
  ├─ V1, V2, V3 = readAverage(ADC_PIN_1/2/3)
  │   └─ 3 ADC reads, average, scale × 0.1299
  ├─ CSQ = getCSQ_RSSI()
  │   └─ AT+CSQ → "+CSQ: rssi,ber" (0-31, 99=unknown)
  ├─ Bv = readBatteryVolts()
  │   └─ 8 ADC reads, voltage divider scale
  ├─ B = percent(Bv, 3.0V-4.05V)
  │   └─ Map to 0-100%
  ├─ TCPU = tempSAMD.readInternalTemperature()
  │   └─ SAMD21 internal sensor
  ├─ X = isPumpOn()
  │   └─ 4 reads of CONTACT_PIN with 20ms debounce
  ├─ P = protectOnStart ? 1 : 0
  ├─ PWR = isPwrPresent()
  │   └─ 4 reads of Input_Supply_V with 20ms debounce
  ├─ FLOW = parameters[0]
  │   └─ From RS485_loop(), current flow (m³/h)
  ├─ TOT = parameters[1]
  │   └─ From RS485_loop(), cumulative (m³)
  └─ AT_UTC = getNetworkTimeISO8601()
      └─ AT+CCLK? → convert to ISO-8601

STEP 2: Adjust publish rate (PWR-aware)
  IF (PWR == 1):  # Main power present
    publishIntervalMs = PUB_FAST_MS (15s)
  ELSE:  # On battery
    IF (B < BAT_THRESH_PCT):  # < 90%
      publishIntervalMs = PUB_SLOW_MS (30s)
    ELSE IF (B >= BAT_THRESH_PCT + BAT_HYST_PCT):  # >= 93%
      publishIntervalMs = PUB_FAST_MS (15s)
    # Keep unchanged if 90% <= B < 93% (hysteresis)

STEP 3: Build plain JSON payload
  {
    "V1": 123, "V2": 456, "V3": 789,
    "X": 1, "P": 0, "B": 85, "CSQ": 18,
    "TCPU": 32.5,
    "FLOW": 1.234, "TOT": 1234.5,
    "RSIM": 5, "RGPRS": 12, "RMQTT": 12,
    "PWR": 1,
    "AT_UTC": "2026-01-20T15:30:45Z"
  }

STEP 4: ChaCha20-Poly1305 encrypt
  ├─ makeNonce12() → [Y(2)|Mo|D|H|Mi|S|counter(5)]
  │   ├─ Get Y-Mo-D-H-Mi-S from network time
  │   └─ counter++ each time, reset when second changes
  ├─ encryptPayload(plain, nonce, key)
  │   ├─ ChaChaPoly.setKey(CRYPTO_KEY, 32)
  │   ├─ ChaChaPoly.setIV(nonce, 12)
  │   ├─ ChaChaPoly.encrypt(plain) → ciphertext
  │   └─ ChaChaPoly.computeTag() → tag[16]
  └─ hexEncode([nonce | ciphertext | tag])
      └─ Uppercase HEX string

STEP 5: Publish via MQTT
  AT+SMPUB="xtr/nodes/{NODE_ID}",{length},1,0
  {hex_payload}


┌──────────────────────────────────────────────────────────────────────────────┐
│ 3.3. CONNECTION CHECK & AUTO RECOVERY (checkConnections)                     │
└──────────────────────────────────────────────────────────────────────────────┘

INTERVAL: Every 15 seconds
CONDITION: Only run when no UART activity in the last 2 seconds

STEP 1: Check AT command (modemAlivePing)
  FOR attempt = 1 TO 3:
    IF (modemAlivePing() == OK):
      atFailStreak = 0
      lastATokMs = now
      GOTO STEP_2
    DELAY 180ms
  
  # No AT response after 3 tries
  atFailStreak++
  
  IF (now - lastATokMs < 16s AND atFailStreak < 2):
    # Grace period - was OK recently
    RETURN
  
  IF (atFailStreak < 2):
    # Not enough threshold
    RETURN
  
  IF (now - lastRestartMs < 15s):
    # Debounce - restarted recently
    RETURN
  
  # Modem not responding → Restart
  modemRestart()
  atFailStreak = 0
  gprsConnect()
  mqttConnect()
  RETURN

STEP 2: Check GPRS (gprsIsConnected)
  IF (gprsIsConnected() == FALSE):
    FOR attempt = 1 TO 3:
      IF (gprsConnect() == OK):
        gprsFailStreak = 0
        GOTO STEP_3
      DELAY 700ms
    
    # GPRS fail after 3 tries
    gprsFailStreak++
    
    IF (now - lastGPRSokMs < 16s AND gprsFailStreak < 3):
      RETURN  # Grace period
    
    IF (gprsFailStreak < 3):
      RETURN  # Not enough threshold
    
    IF (now - lastRestartMs < 15s):
      RETURN  # Debounce
    
    # GPRS fail repeatedly → Restart modem
    modemRestart()
    gprsFailStreak = 0
    gprsConnect()
    mqttConnect()
    RETURN

STEP 3: Check MQTT (checkMQTTConnection)
  IF (checkMQTTConnection() == OK):
    mqttFailStreak = 0
    lastMQTTokMs = now
    RETURN  # All good!
  
  # MQTT disconnected → Try reconnect 3 times
  FOR attempt = 1 TO 3:
    mqttConnect()
    IF (mqttConnected == TRUE):
      mqttFailStreak = 0
      RETURN
    DELAY 900ms
  
  # MQTT still failing → Re-check GPRS
  FOR attempt = 1 TO 3:
    IF (gprsIsConnected() OR gprsConnect()):
      # GPRS OK but MQTT fail
      mqttFailStreak++
      
      IF (now - lastMQTTokMs < 16s AND mqttFailStreak < 3):
        RETURN  # Grace period
      
      IF (mqttFailStreak < 3):
        RETURN  # Not enough threshold
      
      IF (now - lastRestartMs < 15s):
        RETURN  # Debounce
      
      # MQTT fail repeatedly → Restart
      modemRestart()
      mqttFailStreak = 0
      gprsConnect()
      mqttConnect()
      RETURN


┌──────────────────────────────────────────────────────────────────────────────┐
│ 3.4. PUMP CONTROL & PROTECTION MECHANISM                                     │
└──────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ turnOnPump()                                                 │
├─────────────────────────────────────────────────────────────┤
│ 1. CHECK: protectOnStart == TRUE?                          │
│    → YES: Reject + log "protection active (Xs elapsed)"    │
│    → NO: Continue                                           │
│                                                              │
│ 2. CHECK: isPumpOn() == TRUE?                              │
│    → YES: Already ON, skip                                  │
│    → NO: Continue                                           │
│                                                              │
│ 3. ACTUATE:                                                 │
│    digitalWrite(PWR_ON_PIN, HIGH)                           │
│    delay(onPulse)  // Default: 5000ms                       │
│    digitalWrite(PWR_ON_PIN, LOW)                            │
│                                                              │
│ 4. PUBLISH: publishMessage() → update server                │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ turnOffPump()                                                │
├─────────────────────────────────────────────────────────────┤
│ 1. CHECK: isPumpOn() == FALSE?                             │
│    → YES: Already OFF, skip                                 │
│    → NO: Continue                                           │
│                                                              │
│ 2. ACTUATE:                                                 │
│    digitalWrite(PWR_OFF_PIN, HIGH)                          │
│    delay(1000)                                              │
│    digitalWrite(PWR_OFF_PIN, LOW)                           │
│                                                              │
│ 3. PUBLISH: publishMessage() → update server                │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ PROTECTION ON-START (120 seconds)                           │
├─────────────────────────────────────────────────────────────┤
│ TRIGGERED WHEN:                                              │
│   • Pump turned off via HEX command (X=0)                   │
│   • ON→OFF edge detected without HEX (contact sensor)       │
│                                                              │
│ DURING PROTECTION:                                           │
│   • Block all turn-on commands (X=1)                        │
│   • Announce every 10s: "Protection: Xs elapsed"            │
│   • Publish P=1 in JSON                                     │
│                                                              │
│ END:                                                         │
│   • After 120s → protectOnStart = FALSE                     │
│   • Allow normal turn-on again                              │
│                                                              │
│ PURPOSE:                                                     │
│   • Avoid repeated restart (cycling)                        │
│   • Protect motor from damage                               │
│   • Comply with pump operating rules                        │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ isPumpOn() - Read state with debounce                       │
├─────────────────────────────────────────────────────────────┤
│ LOGIC:                                                       │
│   FOR i = 1 TO 4:                                           │
│     highs += (digitalRead(CONTACT_PIN) == HIGH)            │
│     delay(20ms)                                             │
│                                                              │
│   IF (highs == 4): RETURN TRUE   # Definitely ON            │
│   IF (highs == 0): RETURN FALSE  # Definitely OFF           │
│   ELSE: RETURN prevPumpOn        # Ambiguous → keep state   │
│                                                              │
│ PURPOSE: Filter noise, avoid false trigger                   │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ servicePumpEdgeAndStatus() - Detect changes                 │
├─────────────────────────────────────────────────────────────┤
│ nowOn = isPumpOn()                                          │
│                                                              │
│ IF (prevPumpOn == TRUE AND nowOn == FALSE):                │
│   # Edge detected: ON → OFF                                 │
│   IF (lastOffByHexFlag == FALSE):                          │
│     # Turned off NOT via HEX → Activate protection          │
│     armStartProtection("OFF detected by contact")          │
│   ELSE:                                                     │
│     # Turned off via HEX (X=0) → Reset flag                 │
│     lastOffByHexFlag = FALSE                               │
│                                                              │
│ prevPumpOn = nowOn  # Update state                              │
│ pump = nowOn ? 1 : 0                                        │
└─────────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════════════════
4. RS485 MODBUS RTU INTERFACE (Water meter)
═══════════════════════════════════════════════════════════════════════════════

REGISTER ADDRESSES:
  • METER_CURRENT_ADDRESS    = 0x00000002  (Current flow)
  • METER_CUMULATIVE_ADDRESS = 0x00380002  (Cumulative flow)

REQUEST STRUCTURE (8 bytes):
  [Address | Function | RegH | RegL | LenH | LenL | CRCH | CRCL]
  ├─ Address  = 0x01 (Modbus slave address)
  ├─ Function = 0x03 (Read Holding Registers)
  ├─ Register = 4 bytes (big-endian)
  ├─ Length   = 0x0002 (2 registers = 4 bytes data)
  └─ CRC      = RTU CRC-16 (Modbus standard)

RESPONSE STRUCTURE (9 bytes):
  [Address | Function | ByteCount | Data(4) | CRCH | CRCL]
  ├─ Address    = 0x01
  ├─ Function   = 0x03
  ├─ ByteCount  = 0x04
  ├─ Data       = 4 bytes (uint32, big-endian)
  └─ CRC        = RTU CRC-16

PROCESS FLOW:

1. READING_PARAM(address)
   ├─ Build 8-byte request frame
   ├─ Compute Modbus CRC-16
   ├─ RS485.write(frame, 8)
   └─ RS485.flush()

2. PARSING_PARAM(data[1])
   ├─ Wait for first byte (timeout 200ms)
   ├─ Read up to 9 bytes (inter-byte timeout 30ms)
   ├─ Verify CRC
   ├─ Verify header (address, function, bytecount)
   ├─ Extract 4 bytes data → uint32
   └─ RETURN data[0]

3. get_param(regAddr)
   ├─ PARSING_PARAM(raw)
   ├─ SWITCH (regAddr):
   │   CASE METER_CURRENT:
   │     RETURN raw / 1000.0  (scaled to m³/h)
   │   CASE METER_CUMULATIVE:
   │     RETURN (float)raw     (m³)
   └─ RETURN value

4. RS485_loop()
   FOR i in [CURRENT, CUMULATIVE]:
     ├─ READING_PARAM(addr[i])
     ├─ delay(50ms)
     ├─ parameters[i] = get_param(addr[i])
     └─ delay(250ms)

TIMING:
  • Request interval: 50ms between commands
  • Read timeout: 250ms
  • First byte timeout: 200ms
  • Inter-byte timeout: 30ms


═══════════════════════════════════════════════════════════════════════════════
5. ENCRYPTION & SECURITY
═══════════════════════════════════════════════════════════════════════════════

ALGORITHM: ChaCha20-Poly1305 AEAD (Authenticated Encryption)

KEY MANAGEMENT:
  • CRYPTOKEY: 64 hex characters (constant in code)
  • CRYPTO_KEY: 32 bytes binary (decoded from CRYPTOKEY)
  • Shared secret between node and server

NONCE STRUCTURE (12 bytes):
  [Year(2) | Month | Day | Hour | Minute | Second | Counter(5)]
  
  ├─ Bytes 0-1: Year (big-endian uint16, e.g., 0x07EA = 2026)
  ├─ Byte 2:    Month (1-12)
  ├─ Byte 3:    Day (1-31)
  ├─ Byte 4:    Hour (0-23)
  ├─ Byte 5:    Minute (0-59)
  ├─ Byte 6:    Second (0-59)
  └─ Bytes 7-11: Per-second counter (uint40, big-endian)
     └─ Reset to 0 each time second changes
     └─ Increment each time nonce is created
     └─ Ensures unique nonce

ENCRYPT (TX - Node → Server):
  1. makeNonce12()
     ├─ Get Y-M-D-H-Mi-S from getNetworkTimeISO8601()
     ├─ If second changed → reset counter
     ├─ counter++
     └─ Pack into 12 bytes

  2. encryptPayload(plaintext, ciphertext, tag, nonce)
     ├─ ChaChaPoly aead;
     ├─ aead.setKey(CRYPTO_KEY, 32)
     ├─ aead.setIV(nonce, 12)
     ├─ aead.encrypt(ciphertext, plaintext, len)
     └─ aead.computeTag(tag, 16)

  3. HEX Encode
     ├─ hexEncode(nonce, 12) → 24 hex chars
     ├─ hexEncode(ciphertext, len) → len*2 hex chars
     ├─ hexEncode(tag, 16) → 32 hex chars
     └─ Concatenate: [nonce_hex][ct_hex][tag_hex]

DECRYPT (RX - Server → Node):
  1. HEX Decode
     ├─ hexDecode(payload) → binary buffer
     ├─ Extract: nonce[12], tag[16], ct[len-28]
     └─ Verify length >= (12+16)*2 = 56 hex chars

  2. Time Window Check
     ├─ Extract H:M:S from nonce[4:6]
     ├─ secMsg = H*3600 + M*60 + S
     ├─ getNetworkTimeISO8601() → parse H:M:S → secNow
     ├─ Δt = circular_diff(secMsg, secNow)
     └─ IF (Δt > 30s) → REJECT (replay attack protection)

  3. decryptPayload(ct, ctLen, tag, nonce, plain, cap)
     ├─ ChaChaPoly aead;
     ├─ aead.setKey(CRYPTO_KEY, 32)
     ├─ aead.setIV(nonce, 12)
     ├─ aead.decrypt(plain, ct, ctLen)
     ├─ bool ok = aead.checkTag(tag, 16)
     ├─ IF (ok) → plain[ctLen] = '\0'
     └─ RETURN ok

SECURITY:
  ✓ Confidentiality: ChaCha20 stream cipher
  ✓ Integrity: Poly1305 MAC (tag verification)
  ✓ Authentication: Shared secret key
  ✓ Replay Protection: 30-second time window
  ✓ Unique Nonce: Per-second counter + timestamp
  ✓ Transport Security: MQTT over TCP


═══════════════════════════════════════════════════════════════════════════════
6. SIM7070G MODEM MANAGEMENT
═══════════════════════════════════════════════════════════════════════════════

┌──────────────────────────────────────────────────────────────────────────────┐
│ modemRestart() - Hardware restart via PWRKEY                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│ 1. DRAIN BUFFER (40ms)                                                       │
│    └─ Clear UART buffer before operation                                    │
│                                                                               │
│ 2. CHECK AT                                                                  │
│    └─ If modem already responds to AT → skip restart (already on)           │
│                                                                               │
│ 3. FIRST PWRKEY PULSE (toggle)                                               │
│    ├─ digitalWrite(MODEM_PWR_PIN, HIGH)                                      │
│    ├─ delay(1600ms)  // Valid pulse: 1.5-2.0s                               │
│    ├─ digitalWrite(MODEM_PWR_PIN, LOW)                                       │
│    └─ Purpose: Toggle state (ON→OFF or OFF→ON)                              │
│                                                                               │
│ 4. WAIT OFF (9000ms)                                                         │
│    └─ Give modem enough time to shutdown if pulse #1 was OFF                │
│                                                                               │
│ 5. CHECK AT AGAIN                                                            │
│    └─ If respond OK → modem is ON → done                                    │
│                                                                               │
│ 6. SECOND PWRKEY PULSE (force ON)                                            │
│    ├─ digitalWrite(MODEM_PWR_PIN, HIGH)                                      │
│    ├─ delay(1600ms)                                                          │
│    ├─ digitalWrite(MODEM_PWR_PIN, LOW)                                       │
│    └─ Purpose: Ensure modem is ON                                            │
│                                                                               │
│ 7. WAIT BOOT (6000ms)                                                        │
│    └─ Allow modem to boot fully                                             │
│                                                                               │
│ 8. POST-RESTART CONFIG                                                      │
│    ├─ applyBootConfig()                                                      │
│    │   ├─ AT+CMEE=2 (verbose error)                                         │
│    │   ├─ AT+CSOCKSETPN=1 (PDP profile)                                     │
│    │   ├─ AT+SMCONF="CONTEXTID",1                                           │
│    │   └─ AT+CSCLK=0 (disable sleep)                                        │
│    └─ cntModemRestarts++                                                     │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ gprsConnect() - Activate PDP context                                         │
├──────────────────────────────────────────────────────────────────────────────┤
│ 1. CHECK CURRENT STATE                                                       │
│    ├─ AT+CNACT? → "+CNACT: 1,1,..."                                         │
│    └─ If already "1,1" → connected → SKIP                                    │
│                                                                               │
│ 2. CHECK RADIO FUNCTION                                                      │
│    ├─ AT+CFUN? → "+CFUN: ?"                                                 │
│    └─ If != 1 → AT+CFUN=1 (enable radio)                                    │
│                                                                               │
│ 3. CONFIGURE PDP                                                             │
│    ├─ AT+CPSMS=0 (disable PSM)                                              │
│    ├─ AT+CGDCONT=1,"IP","iot.1nce.net"                                      │
│    ├─ AT+CNMP=2 (auto mode: LTE-M/NB-IoT)                                   │
│    └─ AT+CSOCKSETPN=1                                                        │
│                                                                               │
│ 4. ACTIVATE PDP (2 attempts)                                                 │
│    FOR attempt = 1 TO 2:                                                     │
│      ├─ AT+CNACT=1,0 (deactivate)                                           │
│      ├─ AT+CNACT=1,1 (activate)                                             │
│      ├─ AT+CNACT? → verify                                                   │
│      └─ IF "+CNACT: 1,1" → SUCCESS                                          │
│                                                                               │
│ 5. SYNC TIME via NTP                                                         │
│    └─ syncTimeUTC_any(1, 12000ms)                                           │
│                                                                               │
│ 6. UPDATE COUNTERS                                                           │
│    ├─ lastGPRSokMs = millis()                                               │
│    └─ cntGprsConnects++                                                      │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ mqttConnect() - Connect to MQTT broker                                       │
├──────────────────────────────────────────────────────────────────────────────┤
│ 1. PRE-CHECK                                                                 │
│    ├─ gprsIsConnected() → if FALSE → ABORT                                  │
│    ├─ checkMQTTConnection() → if already connected → SKIP                   │
│    └─ ensureATorPowerCycle() → ensure modem responds                        │
│                                                                               │
│ 2. DISCONNECT OLD SESSION                                                    │
│    └─ AT+SMDISC                                                              │
│                                                                               │
│ 3. CONFIGURE MQTT                                                            │
│    ├─ AT+SMCONF="URL","" (clear old)                                        │
│    ├─ AT+SMCONF="URL","broker.remotextr.com"                                │
│    ├─ AT+SMCONF="PORT","1883"                                               │
│    ├─ AT+SMCONF="CLIENTID","{NODE_ID}"                                      │
│    ├─ AT+SMCONF="CLEANSS",1 (clean session)                                 │
│    ├─ AT+SMCONF="QOS","0"                                                    │
│    ├─ AT+SMCONF="RETAIN","0"                                                 │
│    ├─ AT+SMCONF="KEEPTIME",60 (keepalive 60s)                               │
│    ├─ AT+SMCONF="USERNAME","{USERNAME}"                                     │
│    └─ AT+SMCONF="PASSWORD","{PASSWORD}"                                     │
│                                                                               │
│ 4. CONNECT                                                                   │
│    ├─ AT+SMCONN                                                              │
│    ├─ delay(800ms)                                                           │
│    └─ checkMQTTConnection() → verify                                         │
│                                                                               │
│ 5. SUBSCRIBE                                                                 │
│    ├─ AT+SMSUB="xtr/server/{NODE_ID}",1                                     │
│    └─ QoS = 1                                                                │
│                                                                               │
│ 6. UPDATE COUNTERS                                                           │
│    ├─ lastMQTTokMs = millis()                                               │
│    └─ cntMqttConnects++                                                      │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ syncTimeUTC_any() - NTP time sync (fallback 5 servers)                       │
├──────────────────────────────────────────────────────────────────────────────┤
│ SERVERS (priority order):                                                    │
│   1. time.google.com                                                         │
│   2. time.cloudflare.com                                                     │
│   3. pool.ntp.org                                                            │
│   4. time.windows.com                                                        │
│   5. time.nist.gov                                                           │
│                                                                               │
│ FOR EACH server:                                                             │
│   ├─ syncTimeUTC_viaCNTP(cid, server, 12000ms)                              │
│   ├─ IF (success) → RETURN TRUE                                             │
│   └─ ELSE → try next server                                                  │
│                                                                               │
│ syncTimeUTC_viaCNTP(cid, server, timeout):                                   │
│   1. Capture time BEFORE                                                     │
│      └─ AT+CCLK? → timeBefore                                               │
│                                                                               │
│   2. Configure NTP                                                           │
│      ├─ AT+CNTPCID={cid}                                                     │
│      └─ AT+CNTP="{server}",0                                                │
│                                                                               │
│   3. Trigger sync                                                            │
│      └─ AT+CNTP                                                              │
│                                                                               │
│   4. Poll result (loop until timeout)                                        │
│      WHILE (millis() < timeout):                                             │
│        ├─ AT+CNTP?                                                           │
│        ├─ IF "+CNTP: 1" → SUCCESS                                           │
│        ├─ IF "+CNTP: 0" OR "ERROR" → FAIL                                   │
│        └─ delay(600ms)                                                        │
│                                                                               │
│   5. Capture time AFTER                                                      │
│      └─ AT+CCLK? → timeAfter                                                │
│                                                                               │
│   6. Verify change                                                           │
│      └─ IF (timeBefore == timeAfter) → WARNING                              │
│                                                                               │
│   7. RETURN success                                                          │
└──────────────────────────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════════════════
7. STATISTICS & MONITORING
═══════════════════════════════════════════════════════════════════════════════

COUNTERS (published in JSON):
  • RSIM  = cntModemRestarts   - Number of modem restarts
  • RGPRS = cntGprsConnects    - Number of successful GPRS connections
  • RMQTT = cntMqttConnects    - Number of successful MQTT connections

FAIL STREAK TRACKING:
  • atFailStreak    - Consecutive AT command failures (threshold: 2)
  • gprsFailStreak  - Consecutive GPRS check failures (threshold: 3)
  • mqttFailStreak  - Consecutive MQTT check failures (threshold: 3)

TIMESTAMP TRACKING (grace period):
  • lastATokMs    - Last AT OK (grace: 16s)
  • lastGPRSokMs  - Last GPRS OK (grace: 16s)
  • lastMQTTokMs  - Last MQTT OK (grace: 16s)

PUBLISH INTERVAL:
  • publishIntervalMs - Current interval (15s or 30s)
  • lastPublish       - Last publish timestamp

PROTECTION TIMING:
  • protectOnStart     - Protection flag (TRUE/FALSE)
  • protectStartMs     - Protection start timestamp
  • protectLastAnnounce - Last announcement timestamp


═══════════════════════════════════════════════════════════════════════════════
8. IMPORTANT CONFIGURATION
═══════════════════════════════════════════════════════════════════════════════

TIMING CONSTANTS:
  HW_WDT_TIMEOUT_SEC      = 16        // Watchdog timeout
  checkInterval           = 15000     // Health check interval (ms)
  PUB_FAST_MS             = 15000     // Fast publish rate
  PUB_SLOW_MS             = 30000     // Slow publish rate
  PROTECT_ON_MS           = 120000    // Protection duration (2 min)
  PROTECT_TICK_MS         = 10000     // Protection announce interval
  minRestartGapMs         = 15000     // Min gap between restarts
  recentOkGraceMs         = 16000     // Grace period for "recent OK"
  healthQuietMs           = 2000      // UART quiet before health check

THRESHOLDS:
  AT_FAILS_BEFORE_RESTART   = 2
  GPRS_FAILS_BEFORE_RESTART = 3
  MQTT_FAILS_BEFORE_RESTART = 3
  BAT_THRESH_PCT            = 90      // Battery % threshold
  BAT_HYST_PCT              = 3       // Hysteresis

MODEM RESTART TIMING:
  PWRKEY_MS    = 1600     // PWRKEY pulse width (1.5-2.0s valid)
  PRE_DRAIN_MS = 40       // Buffer drain before pulse
  OFF_WAIT_MS  = 9000     // Wait after first pulse
  BOOT_WAIT_MS = 6000     // Wait after second pulse

BATTERY VOLTAGE:
  V_MIN       = 3.00      // 0% battery
  V_MAX       = 4.05      // 100% battery
  R_TOP       = 100000    // Voltage divider top (Ω)
  R_BOTTOM    = 220000    // Voltage divider bottom (Ω)

ADC:
  ADC_VREF    = 3.3       // Reference voltage (V)
  ADC_MAX     = 4095.0    // 12-bit resolution
  ADC_SCALE   = 0.1299    // Scale factor for Nano 33 IoT


═══════════════════════════════════════════════════════════════════════════════
9. PIN MAPPING

MODEM CONTROL:
  MODEM_PWR_PIN    = 12   // SIM7070G power key (PWRKEY)

PUMP CONTROL:
  PWR_ON_PIN       = 4    // Relay ON coil
  PWR_OFF_PIN      = 3    // Relay OFF coil
  CONTACT_PIN      = 20   // Pump state sensor (HIGH=ON, LOW=OFF)

ANALOG INPUTS:
  ADC_PIN_1        = A0   // AC transducer line 1
  ADC_PIN_2        = A1   // AC transducer line 2
  ADC_PIN_3        = A2   // AC transducer line 3
  BATT_VOLTS       = A3   // Battery voltage (via divider)
  Input_Supply_V   = 21   // Main power detection (HIGH=present)

RS485 MODBUS:
  RS485_RX_PIN     = 5    // SERCOM0 RX (PIO_SERCOM_ALT)
  RS485_TX_PIN     = 6    // SERCOM0 TX (PIO_SERCOM_ALT)
  Baudrate         = 9600

SIM7070G:
  Serial1          = sim7070
  Baudrate         = 115200

DEBUG:
  Serial           = USB CDC (115200 bps)


═══════════════════════════════════════════════════════════════════════════════
10. PROTOCOL FORMATS
═══════════════════════════════════════════════════════════════════════════════

┌──────────────────────────────────────────────────────────────────────────────┐
│ MQTT PUBLISH MESSAGE (xtr/nodes/{NODE_ID})                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│ Format: HEX string                                                           │
│ Structure: [nonce(24hex)][ciphertext(variable)][tag(32hex)]                 │
│                                                                               │
│ Decrypted JSON:                                                              │
│ {                                                                             │
│   "V1": <int>,      // AC current line 1 (ADC value)                        │
│   "V2": <int>,      // AC current line 2                                    │
│   "V3": <int>,      // AC current line 3                                    │
│   "X": <0|1>,       // Pump state (0=OFF, 1=ON)                             │
│   "P": <0|1>,       // Protection active (0=NO, 1=YES)                      │
│   "B": <0-100>,     // Battery percentage                                   │
│   "CSQ": <0-31>,    // Signal strength                                      │
│   "TCPU": <float>,  // CPU temperature (°C)                                 │
│   "FLOW": <float>,  // Current water flow (m³/h)                            │
│   "TOT": <float>,   // Cumulative water flow (m³)                           │
│   "RSIM": <int>,    // Modem restart counter                                │
│   "RGPRS": <int>,   // GPRS connect counter                                 │
│   "RMQTT": <int>,   // MQTT connect counter                                 │
│   "PWR": <0|1>,     // Main power present (0=NO, 1=YES)                     │
│   "AT_UTC": <str>   // ISO-8601 timestamp or null                           │
│ }                                                                             │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ MQTT SUBSCRIBE MESSAGE (xtr/server/{NODE_ID})                                │
├──────────────────────────────────────────────────────────────────────────────┤
│ Format: HEX string                                                           │
│ Structure: [nonce(24hex)][ciphertext(variable)][tag(32hex)]                 │
│                                                                               │
│ Decrypted JSON:                                                              │
│ {                                                                             │
│   "X": <0|1>,         // Command: 0=OFF, 1=ON                               │
│   "onPulse": <int>    // Optional: ON pulse duration (500-10000 ms)         │
│ }                                                                             │
│                                                                               │
│ Nonce structure (12 bytes):                                                  │
│   [Y(2)|Mo|D|H|Mi|S|counter(5)]                                             │
│   └─ H:Mi:S used for time window validation (±30s)                          │
└──────────────────────────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════════════════
11. ERROR HANDLING & RECOVERY
═══════════════════════════════════════════════════════════════════════════════

WATCHDOG TIMER:
  • 16 second timeout
  • WDT_RESET() in all wait loops
  • If hung → full MCU hardware reset

AT COMMAND TIMEOUT:
  • Each AT command has its own timeout (100-2500ms)
  • Retry with exponential backoff
  • After threshold → trigger modem restart

GPRS LOSS:
  • Detect: AT+CNACT? does not return "+CNACT: 1,1"
  • Retry: gprsConnect() up to 3 times
  • Fail streak >= 3 → modem restart

MQTT DISCONNECT:
  • Detect: AT+SMSTATE? does not return "+SMSTATE: 1"
  • Retry: mqttConnect() up to 3 times
  • Verify GPRS before retrying MQTT
  • Fail streak >= 3 → modem restart

MODEM HUNG:
  • Detect: AT command no response (3 tries)
  • Recovery: modemRestart() via PWRKEY
  • Double pulse: toggle + force ON

DEBOUNCE & GRACE:
  • minRestartGapMs: 15s between restarts
  • recentOkGraceMs: 16s if was OK recently
  • Avoid restarting too often

UART ACTIVITY TRACKING:
  • noteUartActivity() on every read/write
  • Health check only runs after 2s quiet
  • Avoid conflict with MQTT messages


═══════════════════════════════════════════════════════════════════════════════
12. POWER MANAGEMENT
═══════════════════════════════════════════════════════════════════════════════

BATTERY MONITORING:
  • Read voltage via ADC (8 samples average)
  • Voltage divider: 100kΩ / 220kΩ
  • Map 3.0V-4.05V → 0-100%
  • Update on each publish

ADAPTIVE PUBLISH RATE:
  Priority 1: Main power present
    └─ PWR=1 → ALWAYS fast (15s)
  
  Priority 2: Battery level (when PWR=0)
    ├─ B < 90% → slow (30s)
    └─ B >= 93% → fast (15s)  [hysteresis 3%]

MODEM SLEEP:
  • AT+CSCLK=0 → disable automatic sleep
  • Modem always ON for real-time control
  • Optimize via publish rate instead of sleep

RELAY POWER:
  • Latching relay: only draws power when changing state
  • ON pulse: 5000ms (configurable 500-10000ms)
  • OFF pulse: 1000ms
  • Zero holding current


═══════════════════════════════════════════════════════════════════════════════
13. DESIGN DECISIONS & RATIONALE
═══════════════════════════════════════════════════════════════════════════════

1. Why ChaCha20-Poly1305?
   ├─ AEAD: Encrypt and authenticate in one step
   ├─ Lightweight: Suitable for embedded (vs AES-GCM needs hardware)
   ├─ Modern: More secure than AES-CBC + HMAC
   └─ Performance: Fast on ARM Cortex-M0+

2. Why 30-second time window?
   ├─ Replay attack protection
   ├─ Tolerance for network latency
   ├─ Tight enough for security
   └─ Not too strict (avoid false reject)

3. Why 120-second protection after turn-off?
   ├─ Pump operating rules (avoid cycling)
   ├─ Protect motor from damage
   ├─ Let system stabilize before restart
   └─ Standard practice in pump control

4. Why adaptive publish rate?
   ├─ Save battery when on battery power
   ├─ Real-time when main power present
   ├─ Hysteresis avoids mode flapping
   └─ Balance between responsiveness and power

5. Why debounce 4× 20ms?
   ├─ Filter EMI from relay/motor
   ├─ Avoid false trigger
   ├─ 80ms total: fast enough, stable enough
   └─ Ambiguous → keep previous state (safe choice)

6. Why 16s grace period?
   ├─ Allow temporary network hiccup
   ├─ Avoid unnecessary restarts
   ├─ Watchdog 16s → sync with WDT
   └─ Balance resilience vs recovery speed

7. Why different fail streak thresholds?
   ├─ AT: 2 → serious modem issue, restart early
   ├─ GPRS: 3 → network issue, give more chances
   ├─ MQTT: 3 → app layer, try reconnect multiple times
   └─ Layered recovery strategy

8. Why 5 NTP servers fallback?
   ├─ Reliability: If one server down, use another
   ├─ Geographic diversity: Google, Cloudflare, Pool, Windows, NIST
   ├─ Time critical: Need accurate timestamp for crypto
   └─ Best practice for IoT production


═══════════════════════════════════════════════════════════════════════════════
14. TROUBLESHOOTING GUIDE
═══════════════════════════════════════════════════════════════════════════════

SYMPTOM: Modem restarting repeatedly
  CAUSES:
    • SIM has no signal
    • Wrong APN or SIM not active
    • PWRKEY timing incorrect
  CHECKS:
    • CSQ value (must be > 0, != 99)
    • AT+CNACT? response
    • cntModemRestarts increasing rapidly
  FIXES:
    • Check antenna
    • Verify APN settings
    • Adjust PWRKEY_MS timing

SYMPTOM: MQTT disconnecting often
  CAUSES:
    • GPRS unstable
    • Keepalive timeout
    • Broker issue
  CHECKS:
    • mqttFailStreak value
    • Is AT+CNACT? stable
    • lastMQTTokMs interval
  FIXES:
    • Increase KEEPTIME in SMCONF
    • Check broker availability
    • Adjust MQTT_FAILS_BEFORE_RESTART

SYMPTOM: Control commands not working
  CAUSES:
    • Time window exceeds 30s
    • Wrong crypto key
    • Network time not synced
  CHECKS:
    • Debug log "Time window" message
    • Decrypt result (OK/FAIL)
    • Is AT+CCLK? value valid
  FIXES:
    • Sync NTP right after GPRS connect
    • Verify CRYPTOKEY matches server
    • Increase window to 60s (testing only)

SYMPTOM: Pump won't turn on
  CAUSES:
    • In protection (120s)
    • isPumpOn() already reports ON
    • Relay faulty
  CHECKS:
    • P value in JSON (1=protected)
    • Protection timer log
    • Contact pin reading
  FIXES:
    • Wait for 120s to expire
    • Check wiring CONTACT_PIN
    • Test relay manually

SYMPTOM: Battery drains quickly
  CAUSES:
    • Publish too fast (15s)
    • Modem not sleeping
    • Relay leak current
  CHECKS:
    • publishIntervalMs value
    • PWR field (if =1 then OK)
    • Battery % trend
  FIXES:
    • Ensure PWR detection is correct
    • Increase PUB_SLOW_MS to 60s
    • Check latching relay

SYMPTOM: RS485 not reading
  CAUSES:
    • Wrong wiring (A/B reversed)
    • Baudrate mismatch
    • Wrong Modbus address
  CHECKS:
    • Does RX buffer have data
    • CRC errors
    • TX frame in debug log
  FIXES:
    • Swap RS485_RX/TX or A/B
    • Confirm 9600 baud
    • Verify MODBUS_REQ.address


═══════════════════════════════════════════════════════════════════════════════
END OF SYSTEM ARCHITECTURE
═══════════════════════════════════════════════════════════════════════════════
