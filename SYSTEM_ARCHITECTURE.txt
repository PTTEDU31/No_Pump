╔═══════════════════════════════════════════════════════════════════════════════╗
║          HỆ THỐNG GIÁM SÁT & ĐIỀU KHIỂN MÁY BƠM TỪ XA QUA IoT               ║
║                    Arduino Nano 33 IoT + SIM7070G LTE-M                       ║
╚═══════════════════════════════════════════════════════════════════════════════╝

═══════════════════════════════════════════════════════════════════════════════
1. TỔNG QUAN HỆ THỐNG
═══════════════════════════════════════════════════════════════════════════════

PHẦN CỨNG:
  • MCU: Arduino Nano 33 IoT (SAMD21, ARM Cortex-M0+)
  • Modem: SIM7070G (LTE-M/NB-IoT, UART 115200 bps)
  • RS485: SERCOM0 (9600 bps) - Modbus RTU cho đồng hồ nước
  • Cảm biến:
    - 3x AC Current Transducer (ADC_PIN_1/2/3)
    - Battery Voltage Monitor (voltage divider 100kΩ/220kΩ)
    - Contact Sensor (pump on/off detection)
    - Main Power Detection (Input_Supply_V)
  • Relay: Latching relay (PWR_ON_PIN, PWR_OFF_PIN)

PHẦN MỀM:
  • Framework: Arduino + PlatformIO
  • Giao thức: MQTT over TCP (LTE-M)
  • Mã hóa: ChaCha20-Poly1305 (AEAD)
  • Bảo mật: Time-window authentication (30s), unique nonce
  • Watchdog: 16 giây timeout (Adafruit SleepyDog)

THÔNG SỐ KẾT NỐI:
  • APN: iot.1nce.net (1NCE IoT SIM)
  • MQTT Broker: broker.remotextr.com:1883
  • Topic Subscribe: xtr/server/{NODE_ID}
  • Topic Publish: xtr/nodes/{NODE_ID}
  • Credentials: Username/Password authentication


═══════════════════════════════════════════════════════════════════════════════
2. KIẾN TRÚC PHẦN MỀM
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                               MAIN LOOP                                      │
│                                                                              │
│  [WDT Reset] → [Service Protection] → [Handle MQTT] → [Check Connections]  │
│       ↓              ↓                      ↓                  ↓             │
│  Every cycle    Every cycle          Real-time URC       Every 15s          │
│                 (120s timeout)       parsing                                 │
│                                                                              │
│  ← [Publish Message] ← [Service Pump Edge] ← [RS485 Read] ←                │
│      Every 15s/30s         Real-time            Before publish              │
└─────────────────────────────────────────────────────────────────────────────┘


MODULE CHÍNH:

A. SETUP (Khởi tạo một lần)
   ├─ Watchdog timer init (16s)
   ├─ GPIO configuration (relays, sensors, ADC)
   ├─ Serial interfaces (SIM7070G: 115200, RS485: 9600)
   ├─ Crypto key decode (64 hex chars → 32 bytes)
   ├─ Initial state detection (pump, main power)
   ├─ Modem verification & restart if needed
   ├─ GPRS connection (PDP context activation)
   ├─ MQTT connection & subscription
   └─ Ready to operate

B. LOOP (Vòng lặp chính)
   ├─ WDT_RESET() - Reset watchdog mỗi chu kỳ
   ├─ serviceStartProtection() - Quản lý bảo vệ khởi động
   ├─ handleMQTTMessages() - Xử lý lệnh từ server
   ├─ checkConnections() - Health check (mỗi 15s)
   ├─ servicePumpEdgeAndStatus() - Phát hiện thay đổi trạng thái
   └─ publishMessage() - Gửi dữ liệu (mỗi 15s/30s)


═══════════════════════════════════════════════════════════════════════════════
3. LUỒNG XỬ LÝ CHI TIẾT
═══════════════════════════════════════════════════════════════════════════════

┌──────────────────────────────────────────────────────────────────────────────┐
│ 3.1. NHẬN VÀ XỬ LÝ LỆNH TỪ SERVER (handleMQTTMessages)                      │
└──────────────────────────────────────────────────────────────────────────────┘

BƯỚC 1: Nhận URC từ modem
  → Đợi chuỗi "+SMSUB" từ SIM7070
  → Extract HEX payload từ giữa dấu ngoặc kép

BƯỚC 2: Decode HEX payload
  → hexDecode(payload) → binary buffer
  → Cấu trúc: [nonce(12 bytes) | ciphertext | tag(16 bytes)]
  → Minimum length: (12 + 16) * 2 = 56 hex chars

BƯỚC 3: Lấy timestamp từ nonce
  → nonce[4] = Hour (H)
  → nonce[5] = Minute (M)
  → nonce[6] = Second (S)
  → Convert to seconds: secMsg = H*3600 + M*60 + S

BƯỚC 4: Lấy network time (thử tối đa 5 lần)
  → AT+CCLK? → "+CCLK: "YY/MM/DD,HH:MM:SS+TZ""
  → Parse to ISO-8601: "YYYY-MM-DDTHH:MM:SSZ"
  → Extract HH:MM:SS → secNow
  → Nếu fail 5 lần → discard message

BƯỚC 5: Kiểm tra time window
  → Δt = circular_diff(secMsg, secNow)
  → Nếu Δt > 30s → discard (chống replay attack)

BƯỚC 6: Decrypt payload
  → ChaCha20-Poly1305 decrypt(ciphertext, tag, nonce, key)
  → Verify tag integrity
  → Output: plain JSON

BƯỚC 7: Parse JSON commands
  → jsonGetInt("X", value)
    ├─ X = 1 → turnOnPump() (nếu không trong protection)
    └─ X = 0 → turnOffPump() + armStartProtection(120s)
  → jsonGetInt("onPulse", value)
    └─ Update onPulse (500-10000 ms)

BƯỚC 8: Publish status update
  → Gửi trạng thái mới ngay lập tức


┌──────────────────────────────────────────────────────────────────────────────┐
│ 3.2. PUBLISH DỮ LIỆU (publishMessage)                                        │
└──────────────────────────────────────────────────────────────────────────────┘

BƯỚC 1: Thu thập dữ liệu sensors
  ├─ V1, V2, V3 = readAverage(ADC_PIN_1/2/3)
  │   └─ 3 lần đọc ADC, trung bình, scale × 0.1299
  ├─ CSQ = getCSQ_RSSI()
  │   └─ AT+CSQ → "+CSQ: rssi,ber" (0-31, 99=unknown)
  ├─ Bv = readBatteryVolts()
  │   └─ 8 lần đọc ADC, voltage divider scale
  ├─ B = percent(Bv, 3.0V-4.05V)
  │   └─ Map to 0-100%
  ├─ TCPU = tempSAMD.readInternalTemperature()
  │   └─ SAMD21 internal sensor
  ├─ X = isPumpOn()
  │   └─ 4 lần đọc CONTACT_PIN với debounce 20ms
  ├─ P = protectOnStart ? 1 : 0
  ├─ PWR = isPwrPresent()
  │   └─ 4 lần đọc Input_Supply_V với debounce 20ms
  ├─ FLOW = parameters[0]
  │   └─ Từ RS485_loop(), current flow (m³/h)
  ├─ TOT = parameters[1]
  │   └─ Từ RS485_loop(), cumulative (m³)
  └─ AT_UTC = getNetworkTimeISO8601()
      └─ AT+CCLK? → convert to ISO-8601

BƯỚC 2: Điều chỉnh publish rate (PWR-aware)
  IF (PWR == 1):  # Có nguồn điện chính
    publishIntervalMs = PUB_FAST_MS (15s)
  ELSE:  # Dùng pin
    IF (B < BAT_THRESH_PCT):  # < 90%
      publishIntervalMs = PUB_SLOW_MS (30s)
    ELSE IF (B >= BAT_THRESH_PCT + BAT_HYST_PCT):  # >= 93%
      publishIntervalMs = PUB_FAST_MS (15s)
    # Giữ nguyên nếu 90% <= B < 93% (hysteresis)

BƯỚC 3: Tạo JSON payload (plain)
  {
    "V1": 123, "V2": 456, "V3": 789,
    "X": 1, "P": 0, "B": 85, "CSQ": 18,
    "TCPU": 32.5,
    "FLOW": 1.234, "TOT": 1234.5,
    "RSIM": 5, "RGPRS": 12, "RMQTT": 12,
    "PWR": 1,
    "AT_UTC": "2026-01-20T15:30:45Z"
  }

BƯỚC 4: Mã hóa ChaCha20-Poly1305
  ├─ makeNonce12() → [Y(2)|Mo|D|H|Mi|S|counter(5)]
  │   ├─ Lấy Y-Mo-D-H-Mi-S từ network time
  │   └─ counter++ mỗi lần, reset khi giây thay đổi
  ├─ encryptPayload(plain, nonce, key)
  │   ├─ ChaChaPoly.setKey(CRYPTO_KEY, 32)
  │   ├─ ChaChaPoly.setIV(nonce, 12)
  │   ├─ ChaChaPoly.encrypt(plain) → ciphertext
  │   └─ ChaChaPoly.computeTag() → tag[16]
  └─ hexEncode([nonce | ciphertext | tag])
      └─ Uppercase HEX string

BƯỚC 5: Publish qua MQTT
  AT+SMPUB="xtr/nodes/{NODE_ID}",{length},1,0
  {hex_payload}


┌──────────────────────────────────────────────────────────────────────────────┐
│ 3.3. KIỂM TRA & TỰ ĐỘNG PHỤC HỒI KẾT NỐI (checkConnections)                 │
└──────────────────────────────────────────────────────────────────────────────┘

INTERVAL: Mỗi 15 giây
CONDITION: Chỉ chạy khi không có UART activity trong 2 giây gần nhất

STEP 1: Kiểm tra AT command (modemAlivePing)
  FOR attempt = 1 TO 3:
    IF (modemAlivePing() == OK):
      atFailStreak = 0
      lastATokMs = now
      GOTO STEP_2
    DELAY 180ms
  
  # Không có AT response sau 3 lần
  atFailStreak++
  
  IF (now - lastATokMs < 16s AND atFailStreak < 2):
    # Grace period - gần đây vẫn OK
    RETURN
  
  IF (atFailStreak < 2):
    # Chưa đủ threshold
    RETURN
  
  IF (now - lastRestartMs < 15s):
    # Debounce - vừa restart gần đây
    RETURN
  
  # Modem không phản hồi → Restart
  modemRestart()
  atFailStreak = 0
  gprsConnect()
  mqttConnect()
  RETURN

STEP 2: Kiểm tra GPRS (gprsIsConnected)
  IF (gprsIsConnected() == FALSE):
    FOR attempt = 1 TO 3:
      IF (gprsConnect() == OK):
        gprsFailStreak = 0
        GOTO STEP_3
      DELAY 700ms
    
    # GPRS fail sau 3 lần
    gprsFailStreak++
    
    IF (now - lastGPRSokMs < 16s AND gprsFailStreak < 3):
      RETURN  # Grace period
    
    IF (gprsFailStreak < 3):
      RETURN  # Chưa đủ threshold
    
    IF (now - lastRestartMs < 15s):
      RETURN  # Debounce
    
    # GPRS fail liên tục → Restart modem
    modemRestart()
    gprsFailStreak = 0
    gprsConnect()
    mqttConnect()
    RETURN

STEP 3: Kiểm tra MQTT (checkMQTTConnection)
  IF (checkMQTTConnection() == OK):
    mqttFailStreak = 0
    lastMQTTokMs = now
    RETURN  # All good!
  
  # MQTT disconnected → Thử reconnect 3 lần
  FOR attempt = 1 TO 3:
    mqttConnect()
    IF (mqttConnected == TRUE):
      mqttFailStreak = 0
      RETURN
    DELAY 900ms
  
  # MQTT vẫn fail → Kiểm tra lại GPRS
  FOR attempt = 1 TO 3:
    IF (gprsIsConnected() OR gprsConnect()):
      # GPRS OK nhưng MQTT fail
      mqttFailStreak++
      
      IF (now - lastMQTTokMs < 16s AND mqttFailStreak < 3):
        RETURN  # Grace period
      
      IF (mqttFailStreak < 3):
        RETURN  # Chưa đủ threshold
      
      IF (now - lastRestartMs < 15s):
        RETURN  # Debounce
      
      # MQTT fail liên tục → Restart
      modemRestart()
      mqttFailStreak = 0
      gprsConnect()
      mqttConnect()
      RETURN


┌──────────────────────────────────────────────────────────────────────────────┐
│ 3.4. ĐIỀU KHIỂN MÁY BƠM & CƠ CHẾ BẢO VỆ                                     │
└──────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ turnOnPump()                                                 │
├─────────────────────────────────────────────────────────────┤
│ 1. CHECK: protectOnStart == TRUE?                          │
│    → YES: Reject + log "protection active (Xs elapsed)"    │
│    → NO: Continue                                           │
│                                                              │
│ 2. CHECK: isPumpOn() == TRUE?                              │
│    → YES: Already ON, skip                                  │
│    → NO: Continue                                           │
│                                                              │
│ 3. ACTUATE:                                                 │
│    digitalWrite(PWR_ON_PIN, HIGH)                           │
│    delay(onPulse)  // Default: 5000ms                       │
│    digitalWrite(PWR_ON_PIN, LOW)                            │
│                                                              │
│ 4. PUBLISH: publishMessage() → update server                │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ turnOffPump()                                                │
├─────────────────────────────────────────────────────────────┤
│ 1. CHECK: isPumpOn() == FALSE?                             │
│    → YES: Already OFF, skip                                 │
│    → NO: Continue                                           │
│                                                              │
│ 2. ACTUATE:                                                 │
│    digitalWrite(PWR_OFF_PIN, HIGH)                          │
│    delay(1000)                                              │
│    digitalWrite(PWR_OFF_PIN, LOW)                           │
│                                                              │
│ 3. PUBLISH: publishMessage() → update server                │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ PROTECTION ON-START (120 giây)                              │
├─────────────────────────────────────────────────────────────┤
│ KÍCH HOẠT KHI:                                              │
│   • Tắt máy bơm bằng lệnh HEX (X=0)                        │
│   • Phát hiện edge ON→OFF không qua HEX (contact sensor)   │
│                                                              │
│ TRONG CHẾ ĐỘ BẢO VỆ:                                       │
│   • Chặn tất cả lệnh bật (X=1)                             │
│   • Thông báo mỗi 10s: "Protection: Xs elapsed"            │
│   • Publish P=1 trong JSON                                  │
│                                                              │
│ KẾT THÚC:                                                    │
│   • Sau đủ 120s → protectOnStart = FALSE                   │
│   • Cho phép bật lại bình thường                            │
│                                                              │
│ MỤC ĐÍCH:                                                    │
│   • Tránh khởi động lại liên tục (cycling)                 │
│   • Bảo vệ động cơ khỏi hư hỏng                            │
│   • Tuân thủ quy tắc vận hành máy bơm                      │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ isPumpOn() - Đọc trạng thái với debounce                    │
├─────────────────────────────────────────────────────────────┤
│ LOGIC:                                                       │
│   FOR i = 1 TO 4:                                           │
│     highs += (digitalRead(CONTACT_PIN) == HIGH)            │
│     delay(20ms)                                             │
│                                                              │
│   IF (highs == 4): RETURN TRUE   # Chắc chắn ON            │
│   IF (highs == 0): RETURN FALSE  # Chắc chắn OFF           │
│   ELSE: RETURN prevPumpOn        # Vùng mơ hồ → giữ state  │
│                                                              │
│ MỤC ĐÍCH: Lọc nhiễu, tránh false trigger                    │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ servicePumpEdgeAndStatus() - Phát hiện thay đổi            │
├─────────────────────────────────────────────────────────────┤
│ nowOn = isPumpOn()                                          │
│                                                              │
│ IF (prevPumpOn == TRUE AND nowOn == FALSE):                │
│   # Phát hiện edge: ON → OFF                               │
│   IF (lastOffByHexFlag == FALSE):                          │
│     # Tắt KHÔNG qua lệnh HEX → Kích hoạt bảo vệ           │
│     armStartProtection("OFF detected by contact")          │
│   ELSE:                                                     │
│     # Tắt bằng HEX (X=0) → Reset flag                      │
│     lastOffByHexFlag = FALSE                               │
│                                                              │
│ prevPumpOn = nowOn  # Cập nhật state                        │
│ pump = nowOn ? 1 : 0                                        │
└─────────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════════════════
4. GIAO TIẾP RS485 MODBUS RTU (ĐỒng hồ nước)
═══════════════════════════════════════════════════════════════════════════════

ĐỊA CHỈ REGISTER:
  • METER_CURRENT_ADDRESS    = 0x00000002  (Lưu lượng hiện tại)
  • METER_CUMULATIVE_ADDRESS = 0x00380002  (Lưu lượng tích lũy)

CẤU TRÚC REQUEST (8 bytes):
  [Address | Function | RegH | RegL | LenH | LenL | CRCH | CRCL]
  ├─ Address  = 0x01 (Modbus slave address)
  ├─ Function = 0x03 (Read Holding Registers)
  ├─ Register = 4 bytes (big-endian)
  ├─ Length   = 0x0002 (2 registers = 4 bytes data)
  └─ CRC      = RTU CRC-16 (Modbus standard)

CẤU TRÚC RESPONSE (9 bytes):
  [Address | Function | ByteCount | Data(4) | CRCH | CRCL]
  ├─ Address    = 0x01
  ├─ Function   = 0x03
  ├─ ByteCount  = 0x04
  ├─ Data       = 4 bytes (uint32, big-endian)
  └─ CRC        = RTU CRC-16

LUỒNG XỬ LÝ:

1. READING_PARAM(address)
   ├─ Tạo frame request 8 bytes
   ├─ Tính CRC-16 Modbus
   ├─ RS485.write(frame, 8)
   └─ RS485.flush()

2. PARSING_PARAM(data[1])
   ├─ Đợi byte đầu tiên (timeout 200ms)
   ├─ Đọc đến 9 bytes (inter-byte timeout 30ms)
   ├─ Verify CRC
   ├─ Verify header (address, function, bytecount)
   ├─ Extract 4 bytes data → uint32
   └─ RETURN data[0]

3. get_param(regAddr)
   ├─ PARSING_PARAM(raw)
   ├─ SWITCH (regAddr):
   │   CASE METER_CURRENT:
   │     RETURN raw / 1000.0  (scaled to m³/h)
   │   CASE METER_CUMULATIVE:
   │     RETURN (float)raw     (m³)
   └─ RETURN value

4. RS485_loop()
   FOR i in [CURRENT, CUMULATIVE]:
     ├─ READING_PARAM(addr[i])
     ├─ delay(50ms)
     ├─ parameters[i] = get_param(addr[i])
     └─ delay(250ms)

TIMING:
  • Request interval: 50ms giữa các lệnh
  • Read timeout: 250ms
  • First byte timeout: 200ms
  • Inter-byte timeout: 30ms


═══════════════════════════════════════════════════════════════════════════════
5. MÃ HÓA & BẢO MẬT
═══════════════════════════════════════════════════════════════════════════════

THUẬT TOÁN: ChaCha20-Poly1305 AEAD (Authenticated Encryption)

KEY MANAGEMENT:
  • CRYPTOKEY: 64 hex characters (constant trong code)
  • CRYPTO_KEY: 32 bytes binary (decoded từ CRYPTOKEY)
  • Shared secret giữa node và server

NONCE STRUCTURE (12 bytes):
  [Year(2) | Month | Day | Hour | Minute | Second | Counter(5)]
  
  ├─ Bytes 0-1: Year (big-endian uint16, e.g., 0x07EA = 2026)
  ├─ Byte 2:    Month (1-12)
  ├─ Byte 3:    Day (1-31)
  ├─ Byte 4:    Hour (0-23)
  ├─ Byte 5:    Minute (0-59)
  ├─ Byte 6:    Second (0-59)
  └─ Bytes 7-11: Per-second counter (uint40, big-endian)
     └─ Reset về 0 mỗi khi giây thay đổi
     └─ Tăng mỗi lần tạo nonce
     └─ Đảm bảo nonce unique

ENCRYPT (TX - Node → Server):
  1. makeNonce12()
     ├─ Lấy Y-M-D-H-Mi-S từ getNetworkTimeISO8601()
     ├─ Nếu giây thay đổi → reset counter
     ├─ counter++
     └─ Pack thành 12 bytes

  2. encryptPayload(plaintext, ciphertext, tag, nonce)
     ├─ ChaChaPoly aead;
     ├─ aead.setKey(CRYPTO_KEY, 32)
     ├─ aead.setIV(nonce, 12)
     ├─ aead.encrypt(ciphertext, plaintext, len)
     └─ aead.computeTag(tag, 16)

  3. HEX Encode
     ├─ hexEncode(nonce, 12) → 24 hex chars
     ├─ hexEncode(ciphertext, len) → len*2 hex chars
     ├─ hexEncode(tag, 16) → 32 hex chars
     └─ Concatenate: [nonce_hex][ct_hex][tag_hex]

DECRYPT (RX - Server → Node):
  1. HEX Decode
     ├─ hexDecode(payload) → binary buffer
     ├─ Extract: nonce[12], tag[16], ct[len-28]
     └─ Verify length >= (12+16)*2 = 56 hex chars

  2. Time Window Check
     ├─ Extract H:M:S từ nonce[4:6]
     ├─ secMsg = H*3600 + M*60 + S
     ├─ getNetworkTimeISO8601() → parse H:M:S → secNow
     ├─ Δt = circular_diff(secMsg, secNow)
     └─ IF (Δt > 30s) → REJECT (replay attack protection)

  3. decryptPayload(ct, ctLen, tag, nonce, plain, cap)
     ├─ ChaChaPoly aead;
     ├─ aead.setKey(CRYPTO_KEY, 32)
     ├─ aead.setIV(nonce, 12)
     ├─ aead.decrypt(plain, ct, ctLen)
     ├─ bool ok = aead.checkTag(tag, 16)
     ├─ IF (ok) → plain[ctLen] = '\0'
     └─ RETURN ok

BẢO MẬT:
  ✓ Confidentiality: ChaCha20 stream cipher
  ✓ Integrity: Poly1305 MAC (tag verification)
  ✓ Authentication: Shared secret key
  ✓ Replay Protection: 30-second time window
  ✓ Unique Nonce: Per-second counter + timestamp
  ✓ Transport Security: MQTT over TCP


═══════════════════════════════════════════════════════════════════════════════
6. QUẢN LÝ MODEM SIM7070G
═══════════════════════════════════════════════════════════════════════════════

┌──────────────────────────────────────────────────────────────────────────────┐
│ modemRestart() - Hardware restart qua PWRKEY                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│ 1. DRAIN BUFFER (40ms)                                                       │
│    └─ Xóa sạch UART buffer trước khi thao tác                               │
│                                                                               │
│ 2. CHECK AT                                                                  │
│    └─ Nếu modem đã respond AT → skip restart (already on)                   │
│                                                                               │
│ 3. FIRST PWRKEY PULSE (toggle)                                               │
│    ├─ digitalWrite(MODEM_PWR_PIN, HIGH)                                      │
│    ├─ delay(1600ms)  // Valid pulse: 1.5-2.0s                               │
│    ├─ digitalWrite(MODEM_PWR_PIN, LOW)                                       │
│    └─ Purpose: Toggle state (ON→OFF or OFF→ON)                              │
│                                                                               │
│ 4. WAIT OFF (9000ms)                                                         │
│    └─ Cho modem đủ thời gian shutdown nếu pulse #1 là OFF                   │
│                                                                               │
│ 5. CHECK AT AGAIN                                                            │
│    └─ Nếu respond OK → modem đã ON → done                                   │
│                                                                               │
│ 6. SECOND PWRKEY PULSE (force ON)                                            │
│    ├─ digitalWrite(MODEM_PWR_PIN, HIGH)                                      │
│    ├─ delay(1600ms)                                                          │
│    ├─ digitalWrite(MODEM_PWR_PIN, LOW)                                       │
│    └─ Purpose: Chắc chắn modem ON                                            │
│                                                                               │
│ 7. WAIT BOOT (6000ms)                                                        │
│    └─ Cho modem khởi động hoàn toàn                                         │
│                                                                               │
│ 8. POST-RESTART CONFIG                                                       │
│    ├─ applyBootConfig()                                                      │
│    │   ├─ AT+CMEE=2 (verbose error)                                         │
│    │   ├─ AT+CSOCKSETPN=1 (PDP profile)                                     │
│    │   ├─ AT+SMCONF="CONTEXTID",1                                           │
│    │   └─ AT+CSCLK=0 (disable sleep)                                        │
│    └─ cntModemRestarts++                                                     │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ gprsConnect() - Kích hoạt PDP context                                        │
├──────────────────────────────────────────────────────────────────────────────┤
│ 1. CHECK CURRENT STATE                                                       │
│    ├─ AT+CNACT? → "+CNACT: 1,1,..."                                         │
│    └─ Nếu đã "1,1" → connected → SKIP                                       │
│                                                                               │
│ 2. CHECK RADIO FUNCTION                                                      │
│    ├─ AT+CFUN? → "+CFUN: ?"                                                 │
│    └─ Nếu != 1 → AT+CFUN=1 (enable radio)                                   │
│                                                                               │
│ 3. CONFIGURE PDP                                                             │
│    ├─ AT+CPSMS=0 (disable PSM)                                              │
│    ├─ AT+CGDCONT=1,"IP","iot.1nce.net"                                      │
│    ├─ AT+CNMP=2 (auto mode: LTE-M/NB-IoT)                                   │
│    └─ AT+CSOCKSETPN=1                                                        │
│                                                                               │
│ 4. ACTIVATE PDP (2 attempts)                                                 │
│    FOR attempt = 1 TO 2:                                                     │
│      ├─ AT+CNACT=1,0 (deactivate)                                           │
│      ├─ AT+CNACT=1,1 (activate)                                             │
│      ├─ AT+CNACT? → verify                                                   │
│      └─ IF "+CNACT: 1,1" → SUCCESS                                          │
│                                                                               │
│ 5. SYNC TIME via NTP                                                         │
│    └─ syncTimeUTC_any(1, 12000ms)                                           │
│                                                                               │
│ 6. UPDATE COUNTERS                                                           │
│    ├─ lastGPRSokMs = millis()                                               │
│    └─ cntGprsConnects++                                                      │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ mqttConnect() - Kết nối MQTT broker                                          │
├──────────────────────────────────────────────────────────────────────────────┤
│ 1. PRE-CHECK                                                                 │
│    ├─ gprsIsConnected() → nếu FALSE → ABORT                                 │
│    ├─ checkMQTTConnection() → nếu đã connected → SKIP                       │
│    └─ ensureATorPowerCycle() → đảm bảo modem respond                        │
│                                                                               │
│ 2. DISCONNECT OLD SESSION                                                    │
│    └─ AT+SMDISC                                                              │
│                                                                               │
│ 3. CONFIGURE MQTT                                                            │
│    ├─ AT+SMCONF="URL","" (clear old)                                        │
│    ├─ AT+SMCONF="URL","broker.remotextr.com"                                │
│    ├─ AT+SMCONF="PORT","1883"                                               │
│    ├─ AT+SMCONF="CLIENTID","{NODE_ID}"                                      │
│    ├─ AT+SMCONF="CLEANSS",1 (clean session)                                 │
│    ├─ AT+SMCONF="QOS","0"                                                    │
│    ├─ AT+SMCONF="RETAIN","0"                                                 │
│    ├─ AT+SMCONF="KEEPTIME",60 (keepalive 60s)                               │
│    ├─ AT+SMCONF="USERNAME","{USERNAME}"                                     │
│    └─ AT+SMCONF="PASSWORD","{PASSWORD}"                                     │
│                                                                               │
│ 4. CONNECT                                                                   │
│    ├─ AT+SMCONN                                                              │
│    ├─ delay(800ms)                                                           │
│    └─ checkMQTTConnection() → verify                                         │
│                                                                               │
│ 5. SUBSCRIBE                                                                 │
│    ├─ AT+SMSUB="xtr/server/{NODE_ID}",1                                     │
│    └─ QoS = 1                                                                │
│                                                                               │
│ 6. UPDATE COUNTERS                                                           │
│    ├─ lastMQTTokMs = millis()                                               │
│    └─ cntMqttConnects++                                                      │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ syncTimeUTC_any() - Đồng bộ thời gian NTP (fallback 5 servers)              │
├──────────────────────────────────────────────────────────────────────────────┤
│ SERVERS (theo thứ tự ưu tiên):                                              │
│   1. time.google.com                                                         │
│   2. time.cloudflare.com                                                     │
│   3. pool.ntp.org                                                            │
│   4. time.windows.com                                                        │
│   5. time.nist.gov                                                           │
│                                                                               │
│ FOR EACH server:                                                             │
│   ├─ syncTimeUTC_viaCNTP(cid, server, 12000ms)                              │
│   ├─ IF (success) → RETURN TRUE                                             │
│   └─ ELSE → try next server                                                  │
│                                                                               │
│ syncTimeUTC_viaCNTP(cid, server, timeout):                                   │
│   1. Capture time BEFORE                                                     │
│      └─ AT+CCLK? → timeBefore                                               │
│                                                                               │
│   2. Configure NTP                                                           │
│      ├─ AT+CNTPCID={cid}                                                     │
│      └─ AT+CNTP="{server}",0                                                │
│                                                                               │
│   3. Trigger sync                                                            │
│      └─ AT+CNTP                                                              │
│                                                                               │
│   4. Poll result (loop until timeout)                                        │
│      WHILE (millis() < timeout):                                             │
│        ├─ AT+CNTP?                                                           │
│        ├─ IF "+CNTP: 1" → SUCCESS                                           │
│        ├─ IF "+CNTP: 0" OR "ERROR" → FAIL                                   │
│        └─ delay(600ms)                                                        │
│                                                                               │
│   5. Capture time AFTER                                                      │
│      └─ AT+CCLK? → timeAfter                                                │
│                                                                               │
│   6. Verify change                                                           │
│      └─ IF (timeBefore == timeAfter) → WARNING                              │
│                                                                               │
│   7. RETURN success                                                          │
└──────────────────────────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════════════════
7. THỐNG KÊ & MONITORING
═══════════════════════════════════════════════════════════════════════════════

COUNTERS (published trong JSON):
  • RSIM  = cntModemRestarts   - Số lần restart modem
  • RGPRS = cntGprsConnects    - Số lần kết nối GPRS thành công
  • RMQTT = cntMqttConnects    - Số lần kết nối MQTT thành công

FAIL STREAK TRACKING:
  • atFailStreak    - Chuỗi fail AT command (threshold: 2)
  • gprsFailStreak  - Chuỗi fail GPRS check (threshold: 3)
  • mqttFailStreak  - Chuỗi fail MQTT check (threshold: 3)

TIMESTAMP TRACKING (grace period):
  • lastATokMs    - Lần cuối AT OK (grace: 16s)
  • lastGPRSokMs  - Lần cuối GPRS OK (grace: 16s)
  • lastMQTTokMs  - Lần cuối MQTT OK (grace: 16s)

PUBLISH INTERVAL:
  • publishIntervalMs - Chu kỳ hiện tại (15s hoặc 30s)
  • lastPublish       - Timestamp lần publish cuối

PROTECTION TIMING:
  • protectOnStart     - Flag bảo vệ (TRUE/FALSE)
  • protectStartMs     - Timestamp bắt đầu bảo vệ
  • protectLastAnnounce - Timestamp thông báo cuối


═══════════════════════════════════════════════════════════════════════════════
8. CẤU HÌNH QUAN TRỌNG
═══════════════════════════════════════════════════════════════════════════════

TIMING CONSTANTS:
  HW_WDT_TIMEOUT_SEC      = 16        // Watchdog timeout
  checkInterval           = 15000     // Health check interval (ms)
  PUB_FAST_MS             = 15000     // Fast publish rate
  PUB_SLOW_MS             = 30000     // Slow publish rate
  PROTECT_ON_MS           = 120000    // Protection duration (2 min)
  PROTECT_TICK_MS         = 10000     // Protection announce interval
  minRestartGapMs         = 15000     // Min gap between restarts
  recentOkGraceMs         = 16000     // Grace period for "recent OK"
  healthQuietMs           = 2000      // UART quiet before health check

THRESHOLDS:
  AT_FAILS_BEFORE_RESTART   = 2
  GPRS_FAILS_BEFORE_RESTART = 3
  MQTT_FAILS_BEFORE_RESTART = 3
  BAT_THRESH_PCT            = 90      // Battery % threshold
  BAT_HYST_PCT              = 3       // Hysteresis

MODEM RESTART TIMING:
  PWRKEY_MS    = 1600     // PWRKEY pulse width (1.5-2.0s valid)
  PRE_DRAIN_MS = 40       // Buffer drain before pulse
  OFF_WAIT_MS  = 9000     // Wait after first pulse
  BOOT_WAIT_MS = 6000     // Wait after second pulse

BATTERY VOLTAGE:
  V_MIN       = 3.00      // 0% battery
  V_MAX       = 4.05      // 100% battery
  R_TOP       = 100000    // Voltage divider top (Ω)
  R_BOTTOM    = 220000    // Voltage divider bottom (Ω)

ADC:
  ADC_VREF    = 3.3       // Reference voltage (V)
  ADC_MAX     = 4095.0    // 12-bit resolution
  ADC_SCALE   = 0.1299    // Scale factor for Nano 33 IoT


═══════════════════════════════════════════════════════════════════════════════
9. PIN MAPPING
═══════════════════════════════════════════════════════════════════════════════

MODEM CONTROL:
  MODEM_PWR_PIN    = 12   // SIM7070G power key (PWRKEY)

PUMP CONTROL:
  PWR_ON_PIN       = 4    // Relay ON coil
  PWR_OFF_PIN      = 3    // Relay OFF coil
  CONTACT_PIN      = 20   // Pump state sensor (HIGH=ON, LOW=OFF)

ANALOG INPUTS:
  ADC_PIN_1        = A0   // AC transducer line 1
  ADC_PIN_2        = A1   // AC transducer line 2
  ADC_PIN_3        = A2   // AC transducer line 3
  BATT_VOLTS       = A3   // Battery voltage (via divider)
  Input_Supply_V   = 21   // Main power detection (HIGH=present)

RS485 MODBUS:
  RS485_RX_PIN     = 5    // SERCOM0 RX (PIO_SERCOM_ALT)
  RS485_TX_PIN     = 6    // SERCOM0 TX (PIO_SERCOM_ALT)
  Baudrate         = 9600

SIM7070G:
  Serial1          = sim7070
  Baudrate         = 115200

DEBUG:
  Serial           = USB CDC (115200 bps)


═══════════════════════════════════════════════════════════════════════════════
10. PROTOCOL FORMATS
═══════════════════════════════════════════════════════════════════════════════

┌──────────────────────────────────────────────────────────────────────────────┐
│ MQTT PUBLISH MESSAGE (xtr/nodes/{NODE_ID})                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│ Format: HEX string                                                           │
│ Structure: [nonce(24hex)][ciphertext(variable)][tag(32hex)]                 │
│                                                                               │
│ Decrypted JSON:                                                              │
│ {                                                                             │
│   "V1": <int>,      // AC current line 1 (ADC value)                        │
│   "V2": <int>,      // AC current line 2                                    │
│   "V3": <int>,      // AC current line 3                                    │
│   "X": <0|1>,       // Pump state (0=OFF, 1=ON)                             │
│   "P": <0|1>,       // Protection active (0=NO, 1=YES)                      │
│   "B": <0-100>,     // Battery percentage                                   │
│   "CSQ": <0-31>,    // Signal strength                                      │
│   "TCPU": <float>,  // CPU temperature (°C)                                 │
│   "FLOW": <float>,  // Current water flow (m³/h)                            │
│   "TOT": <float>,   // Cumulative water flow (m³)                           │
│   "RSIM": <int>,    // Modem restart counter                                │
│   "RGPRS": <int>,   // GPRS connect counter                                 │
│   "RMQTT": <int>,   // MQTT connect counter                                 │
│   "PWR": <0|1>,     // Main power present (0=NO, 1=YES)                     │
│   "AT_UTC": <str>   // ISO-8601 timestamp or null                           │
│ }                                                                             │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ MQTT SUBSCRIBE MESSAGE (xtr/server/{NODE_ID})                                │
├──────────────────────────────────────────────────────────────────────────────┤
│ Format: HEX string                                                           │
│ Structure: [nonce(24hex)][ciphertext(variable)][tag(32hex)]                 │
│                                                                               │
│ Decrypted JSON:                                                              │
│ {                                                                             │
│   "X": <0|1>,         // Command: 0=OFF, 1=ON                               │
│   "onPulse": <int>    // Optional: ON pulse duration (500-10000 ms)         │
│ }                                                                             │
│                                                                               │
│ Nonce structure (12 bytes):                                                  │
│   [Y(2)|Mo|D|H|Mi|S|counter(5)]                                             │
│   └─ H:Mi:S used for time window validation (±30s)                          │
└──────────────────────────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════════════════
11. ERROR HANDLING & RECOVERY
═══════════════════════════════════════════════════════════════════════════════

WATCHDOG TIMER:
  • 16 giây timeout
  • WDT_RESET() trong tất cả vòng lặp chờ
  • Nếu treo → hardware reset toàn bộ MCU

AT COMMAND TIMEOUT:
  • Mỗi AT command có timeout riêng (100-2500ms)
  • Retry với exponential backoff
  • Sau threshold → trigger modem restart

GPRS LOSS:
  • Detect: AT+CNACT? không trả về "+CNACT: 1,1"
  • Retry: gprsConnect() tối đa 3 lần
  • Fail streak >= 3 → modem restart

MQTT DISCONNECT:
  • Detect: AT+SMSTATE? không trả về "+SMSTATE: 1"
  • Retry: mqttConnect() tối đa 3 lần
  • Verify GPRS trước khi retry MQTT
  • Fail streak >= 3 → modem restart

MODEM HUNG:
  • Detect: AT command không response (3 lần)
  • Recovery: modemRestart() qua PWRKEY
  • Double pulse: toggle + force ON

DEBOUNCE & GRACE:
  • minRestartGapMs: 15s giữa các restart
  • recentOkGraceMs: 16s nếu vừa OK gần đây
  • Tránh restart quá thường xuyên

UART ACTIVITY TRACKING:
  • noteUartActivity() mỗi khi read/write
  • Health check chỉ chạy sau 2s quiet
  • Tránh conflict với MQTT messages


═══════════════════════════════════════════════════════════════════════════════
12. POWER MANAGEMENT
═══════════════════════════════════════════════════════════════════════════════

BATTERY MONITORING:
  • Đọc voltage qua ADC (8 samples average)
  • Voltage divider: 100kΩ / 220kΩ
  • Map 3.0V-4.05V → 0-100%
  • Update mỗi lần publish

ADAPTIVE PUBLISH RATE:
  Priority 1: Main power present
    └─ PWR=1 → ALWAYS fast (15s)
  
  Priority 2: Battery level (when PWR=0)
    ├─ B < 90% → slow (30s)
    └─ B >= 93% → fast (15s)  [hysteresis 3%]

MODEM SLEEP:
  • AT+CSCLK=0 → disable automatic sleep
  • Modem luôn ON cho real-time control
  • Tối ưu bằng publish rate thay vì sleep

RELAY POWER:
  • Latching relay: chỉ dùng điện khi chuyển state
  • ON pulse: 5000ms (configurable 500-10000ms)
  • OFF pulse: 1000ms
  • Zero holding current


═══════════════════════════════════════════════════════════════════════════════
13. DESIGN DECISIONS & RATIONALE
═══════════════════════════════════════════════════════════════════════════════

1. Tại sao dùng ChaCha20-Poly1305?
   ├─ AEAD: Vừa mã hóa, vừa xác thực trong một bước
   ├─ Lightweight: Phù hợp với embedded (vs AES-GCM cần hardware)
   ├─ Modern: An toàn hơn AES-CBC + HMAC
   └─ Performance: Nhanh trên ARM Cortex-M0+

2. Tại sao time window 30 giây?
   ├─ Chống replay attack
   ├─ Dung sai cho network latency
   ├─ Đủ chặt để bảo mật
   └─ Không quá khắt khe (tránh false reject)

3. Tại sao bảo vệ 120 giây sau khi tắt?
   ├─ Quy tắc vận hành máy bơm (tránh cycling)
   ├─ Bảo vệ động cơ khỏi hư hỏng
   ├─ Cho hệ thống ổn định trước khi restart
   └─ Standard practice trong pump control

4. Tại sao adaptive publish rate?
   ├─ Tiết kiệm pin khi dùng battery
   ├─ Real-time khi có nguồn chính
   ├─ Hysteresis tránh nhảy chế độ liên tục
   └─ Balance giữa responsiveness và power

5. Tại sao debounce 4 lần × 20ms?
   ├─ Lọc nhiễu điện từ relay/motor
   ├─ Tránh false trigger
   ├─ 80ms total: đủ nhanh, đủ ổn định
   └─ Vùng mơ hồ → giữ state cũ (safe choice)

6. Tại sao grace period 16s?
   ├─ Cho phép network hiccup tạm thời
   ├─ Tránh restart không cần thiết
   ├─ Watchdog 16s → sync với WDT
   └─ Balance giữa resilience và recovery speed

7. Tại sao fail streak thresholds khác nhau?
   ├─ AT: 2 → modem issue nghiêm trọng, restart sớm
   ├─ GPRS: 3 → network issue, cho nhiều cơ hội hơn
   ├─ MQTT: 3 → app layer, thử reconnect nhiều lần
   └─ Layered recovery strategy

8. Tại sao 5 NTP servers fallback?
   ├─ Reliability: Nếu 1 server down, dùng server khác
   ├─ Geographic diversity: Google, Cloudflare, Pool, Windows, NIST
   ├─ Time critical: Cần timestamp chính xác cho crypto
   └─ Best practice cho IoT production


═══════════════════════════════════════════════════════════════════════════════
14. TROUBLESHOOTING GUIDE
═══════════════════════════════════════════════════════════════════════════════

SYMPTOM: Modem restart liên tục
  CAUSES:
    • SIM không có tín hiệu
    • APN sai hoặc SIM không active
    • PWRKEY timing không đúng
  CHECKS:
    • CSQ value (phải > 0, != 99)
    • AT+CNACT? response
    • cntModemRestarts tăng nhanh
  FIXES:
    • Kiểm tra antenna
    • Verify APN settings
    • Adjust PWRKEY_MS timing

SYMPTOM: MQTT disconnect thường xuyên
  CAUSES:
    • GPRS không ổn định
    • Keepalive timeout
    • Broker issue
  CHECKS:
    • mqttFailStreak value
    • AT+CNACT? có stable không
    • lastMQTTokMs interval
  FIXES:
    • Tăng KEEPTIME trong SMCONF
    • Check broker availability
    • Adjust MQTT_FAILS_BEFORE_RESTART

SYMPTOM: Lệnh điều khiển không hoạt động
  CAUSES:
    • Time window vượt 30s
    • Crypto key sai
    • Network time chưa sync
  CHECKS:
    • Debug log "Time window" message
    • Decrypt result (OK/FAIL)
    • AT+CCLK? có giá trị hợp lệ
  FIXES:
    • Sync NTP ngay sau GPRS connect
    • Verify CRYPTOKEY match với server
    • Tăng window lên 60s (testing only)

SYMPTOM: Pump không bật được
  CAUSES:
    • Đang trong protection (120s)
    • isPumpOn() đã báo ON
    • Relay hỏng
  CHECKS:
    • P value trong JSON (1=protected)
    • Protection timer log
    • Contact pin reading
  FIXES:
    • Đợi hết 120s
    • Check wiring CONTACT_PIN
    • Test relay manually

SYMPTOM: Battery drain nhanh
  CAUSES:
    • Publish quá nhanh (15s)
    • Modem không sleep
    • Relay leak current
  CHECKS:
    • publishIntervalMs value
    • PWR field (nếu =1 thì OK)
    • Battery % trend
  FIXES:
    • Đảm bảo PWR detection chính xác
    • Tăng PUB_SLOW_MS lên 60s
    • Check latching relay

SYMPTOM: RS485 không đọc được
  CAUSES:
    • Wiring sai (A/B reversed)
    • Baudrate không match
    • Modbus address sai
  CHECKS:
    • RX buffer có data không
    • CRC errors
    • TX frame trong debug log
  FIXES:
    • Swap RS485_RX/TX hoặc A/B
    • Confirm 9600 baud
    • Verify MODBUS_REQ.address


═══════════════════════════════════════════════════════════════════════════════
END OF SYSTEM ARCHITECTURE
═══════════════════════════════════════════════════════════════════════════════
